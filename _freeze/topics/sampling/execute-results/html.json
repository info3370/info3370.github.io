{
  "hash": "82aaf3d93bf1cfa5f71a1c93b9e77dd6",
  "result": {
    "markdown": "---\ntitle: \"Population Sampling\"\n---\n\n::: {.cell}\n\n:::\n\n\n[[Slides]](../slides/lec2/lec2.pdf)\n\nClaims about inequality are often claims about a population. Our data are typically only a sample! This module addresses the link between samples and populations.\n\nThis page covers two lecture (1/30 and 2/6).\n\n- Lecture on 1/30 covers [full count enumeration](#full-count-enumeration) through the [Current Population Survey](#sec-cps). After lecture, you should read about [probability sampling](https://www150.statcan.gc.ca/n1/edu/power-pouvoir/ch13/prob/5214899-eng.htm) and register for an account at [cps.ipums.org](https://cps.ipums.org/cps/).\n- Lecture on 2/6 uses salaries of [Major League Baseball players](#sec-baseball) to carry out three sampling strategies and explore their performance. After class, you should read [Groves 2011](https://academic.oup.com/poq/article/75/5/861/1831518) on the past and future of sampling\n\n::: {.callout-tip}\n### Heads-up!\nYou will want your computer in lecture on 2/6.\n:::\n    \n## Full count enumeration\n\nWhat proportion of our class prefers to sit in the front of the room?\n\nWe answered this question in class using **full count enumeration**: list the entire target population and ask them the question. Full count enumeration is ideal because it removes all statistical sources of error. But in settings with a larger target population, the high cost of full count enumeration may be prohibitive.\n\n## Simple random sample\n\nWe carried out a **simple random sample**^[Technically, a simple random sample draws units independently with equal probabilities, and with replacement. Our sample is actually drawn without replacement. In an infinite population, the two are equivalent.] in class.\n\n- everyone generated a random number between 0 and 1\n- those with values less than 0.1 were sampled\n- our sample estimate was the proportion of those sampled to prefer the front of the room\n\nIn a simple random sample, each person in the population is sampled with equal probabilities. Because the probabilities are known, a simple random sample is a **probability sample**.\n\n\n{{< video https://www.youtube.com/embed/IDGKgpiM218 >}}\n\n\n\n## Unequal probability sample\n\nSuppose we want to make subgroup estimates:\n\n- what proportion prefer the front, among those sitting in the first 3 rows?\n- what proportion prefer the front, among those sitting in the back 17 rows?\n\nIn a simple random sample, we might only get a few or even zero people in the first 3 rows! To reduce the chance of this bad sample, we could draw an unequal probability sample:\n\n- those in rows 1--3 are selected with probability 0.5\n- those in rows 4--20 are selected with probability 0.1\n\nOur unequal probability sample will over-represent the first three rows, thus creating a large enough sample in this subgroup to yield precise estimates.\n\n\n{{< video https://www.youtube.com/embed/4r_85uHrNY0 >}}\n\n\n\nHaving drawn an unequal probability sample, suppose we now want to estimate the class-wide proportion who prefer sitting in the front. We will have a problem: those who prefer the front may be more likely to sit there, and they are also sampled with a higher probability! Sample inclusion is related to the value of our outcome.\n\nBecause the sampling probabilities are known, we can correct for this by applying **sampling weights**, which for each person equals the inverse of the known probability of inclusion for that person.\n\nFor those in rows 1--3,\n\n- we sampled with probability 50\\%\n- on average 1 in every 2 people is sampled\n- each person in the sample represents 2 people in the population\n- $w_i = \\frac{1}{\\text{P}(\\text{Sampled}_i)} = \\frac{1}{.5} = 2$\n\nFor those in rows 4--20,\n\n- we sampled with probability 10\\%\n- on average 1 in every 10 people is sampled\n- each person in the sample represents 10 people in the population\n- $w_i = \\frac{1}{\\text{P}(\\text{Sampled}_i)} = \\frac{1}{.1} = 10$\n\nTo estimate the population mean, we can use the weighted sample mean,\n\n$$\\frac{\\sum_i y_iw_i}{\\sum_i w_i}$$\n\n\n{{< video https://www.youtube.com/embed/nczwdCiTmMk >}}\n\n\n\n## Stratified random sample\n\nWe could also draw a **stratified random sample** by first partitioning the population into subgroups (called **strata**) and then drawing samples within each subgroup. For instance,\n\n- sample 10 of the 20 people in rows 1--3\n- sample 10 of the 130 people in rows 4--17\n\nIn simple random or unequal probability sampling, it is always possible that by random chance we sample no one in the front of the room. Stratified random sampling rules this out: we know in advance how our sample will be balanced across the two strata.\n\n::: {.callout-note}\nIn our real-data example at the end of this page, the Current Population Survey is stratified by state so that the Bureau of Labor Statistics knows in advance that they will gather a sufficient sample to estimate unemployment in each state.\n:::\n\n## A real case: The Current Population Survey {#sec-cps}\n\nEvery month, the Bureau of Labor Statistics in collaboration with the U.S. Census Bureau collects data on unemployment in the Current Population Survey (CPS). The CPS is a probability sample designed to estimate the unemployment rate in the U.S. and in each state.\n\nWe will be using the CPS in discussion. This video introduces the CPS and points you toward where you can access the data via [IPUMS-CPS](https://cps.ipums.org/cps/).\n\n\n{{< video https://www.youtube.com/embed/1VxcmPOWwG0 >}}\n\n\n\n## Example: Baseball players {#sec-baseball}\n\nAs one example where full-count enumeration is possible, we will examine the salaries of all 944 Major League Baseball Players who were on active rosters, injured lists, and restricted lists on Opening Day 2023. These data were compiled by [USA Today](https://databases.usatoday.com/major-league-baseball-salaries-2023/) and are available in [baseball.csv](../data/baseball.csv).\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 944 × 4\n  player            team         position   salary\n  <chr>             <chr>        <chr>       <dbl>\n1 Scherzer, Max     N.Y. Mets    RHP      43333333\n2 Verlander, Justin N.Y. Mets    RHP      43333333\n3 Judge, Aaron      N.Y. Yankees OF       40000000\n4 Rendon, Anthony   L.A. Angels  3B       38571429\n5 Trout, Mike       L.A. Angels  OF       37116667\n# ℹ 939 more rows\n```\n:::\n:::\n\n\nSalaries are high, and income inequality is also high among baseball players\n\n- 4% were paid the league minimum of \\$720,000\n- 53% were paid less than \\$2,000,000\n- the highest-paid players---Max Scherzer and Justin Verlander---each earned $43,333,333\n- the highest-paid half of players take home 92% of the total pay\n\nWhile the  of players were paid less than \\$2,000,000\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](sampling_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSuppose you did not have the whole population, and you wanted to learn the mean salary. A statistician might propose 3 strategies to sample 60 players\n\nA) Sample 60 players out of the 944 with equal probabilities\nB) Sample 2 players in each of the 30 teams\nC) Sample 3 teams. Then sample 20 players on each team\n\nIdentify which of these strategies corresponds to\n\n- a clustered sample\n- a simple random sample\n- a stratified random sample\n\nThen think about which strategy might\n\n- be least expensive?\n- have the best statistical properties?\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n### Good to know\nPay varies widely across teams! <!--The Oakland Athletics had both the lowest average salary ($1,835,323) and the lowest standard deviation of salaries ($1,813,831). The N.Y. Mets had both the highest average salary ($9,769,902) and the highest standard deviation of salaries ($11,690,343).-->\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](sampling_files/figure-html/unnamed-chunk-5-1.png){width=480}\n:::\n:::\n\n:::\n\nIn class, we will explore the properties of samples drawn by strategies A, B, and C. Below is code that implements these strategies.\n\n### Strategy A: 60 players\n\nSample 60 players from the entire league. Each player's probability of sample inclusion is $\\frac{60}{n}$ where $n$ is the number of players in the league (944).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Strategy A\ndraw_sample_A <- function(population) {\n  population |>\n    # Define sampling probability and weight\n    mutate(\n      p_sampled = 60 / n(),\n      sampling_weight = 1 / p_sampled\n    ) |>\n    # Sample 60 players\n    sample_n(size = 60)\n}\n```\n:::\n\n\n### Strategy B: 2 players per team\n\nSample 2 players from each of the 30 teams. Each player's probability of sample inclusion is $\\frac{2}{n}$ where $n$ is the number on that player's team (which ranges from 28 to 35).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Strategy B\ndraw_sample_B <- function(population) {\n  population |>\n    # Draw sample within each team\n    group_by(team) |>\n    # Define sampling probability and weight\n    mutate(\n      p_sampled = 2 / n(),\n      sampling_weight = 1 / p_sampled\n    ) |>\n    # Within each team, sample 2 players\n    sample_n(size = 2)\n}\n```\n:::\n\n\n### Strategy C: 20 players on 3 teams\n\nSample 3 out of the 30 teams, then sample 20 players in each sampled team. Each player's probability of sample inclusion is P(Team Chosen) $\\times$ P(Chosen Within Team) = $\\frac{3}{30}\\times\\frac{20}{n}$ where $n$ is the number on that player's team (which ranges from 28 to 35).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Strategy C\ndraw_sample_C <- function(population) {\n  \n  # First, sample 3 teams\n  sampled_teams <- population |>\n    # Make one row per team\n    distinct(team) |>\n    # Sample 3 teams\n    sample_n(3) |>\n    # Store those 3 team names in a vector\n    pull()\n  \n  # Load all data\n  population |>\n    # Restrict to the chosen teams\n    filter(team %in% sampled_teams) |>\n    # Define sampling probability and weight\n    group_by(team) |>\n    mutate(\n      p_sampled = (3 / 30) * (20 / n()),\n      sampling_weight = 1 / p_sampled\n    )\n    # Sample 20 players\n    sample_n(20) |>\n    ungroup()\n}\n```\n:::\n\n\n### Weighted mean estimator\n\nFor any given sample, the estimator below will return a weighted mean estimate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimator <- function(sample) {\n  sample |>\n    summarize(estimate = weighted.mean(\n      x = salary, \n      w = sampling_weight\n    )) |>\n    pull(estimate)\n}\n```\n:::\n\n\n### Evaluating performance: One sample\n\nThe true mean salary in the league is $4,965,481. How close do you come with each strategy?\n\nHere is how to use the code above to carry out strategy A.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_A <- draw_sample_A(population = baseball)\nestimator(sample = sample_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4041599\n```\n:::\n:::\n\n\n### Evaluating performance: Many samples\n\nWe might like to know something about performance across many repeated samples. The `replicate` function will carry out a set of code many times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_estimates_A <- replicate(\n  n = 1000,\n  expr = {\n    sample_A <- draw_sample_A(population = baseball)\n    estimator(sample = sample_A)\n  }\n)\n```\n:::\n\n\nSimulate many samples. Which one is the best? Strategy A, B, or C?\n\n## The future of sample surveys\n\nSample surveys served as a cornerstone of social science research from the 1950s to the present. But there are concerns about their future:\n\n- some sampling frames, such as landline telephones, have become obsolete\n- response rates have been falling for decades\n- sample surveys are slower and more expensive than digital data\n\nWhat is the future for sample surveys? How can they be combined with other data?\n\nWe will close with a discussion of these questions, which you can also engage with in the [Groves 2011](https://academic.oup.com/poq/article/75/5/861/1831518) reading that follows this module.\n",
    "supporting": [
      "sampling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}